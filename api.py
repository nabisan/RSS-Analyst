#!/usr/bin/env python
"""
RSS Analyst 1.0 - FastAPI Endpoints
Production API for analyst accuracy tracking and RSS feeds.
"""

from fastapi import FastAPI, HTTPException, Query, Depends
from fastapi.responses import FileResponse
from pydantic import BaseModel
from typing import List, Optional
import polars as pl
from loguru import logger
from pathlib import Path
import httpx
from datetime import datetime
import asyncio
import pytz
from dotenv import load_dotenv
import os

load_dotenv()
API_KEY = os.getenv("FMP_API_KEY")
DB_PATH = "analyst_data.duckdb"

app = FastAPI(
    title="RSS Analyst 1.0 API",
    description="Production analyst accuracy tracker with Polars/DuckDB backend",
    version="1.0.0"
)

# DuckDB connection
conn = pl.duckdb.connect(DB_PATH)

class AnalystScore(BaseModel):
    analyst_name: str
    skill_score: float
    accuracy: float
    avg_error: float
    total_predictions: int
    diversity: int
    updated_at: datetime

class PriceTarget(BaseModel):
    symbol: str
    analyst_name: str
    analyst_company: str
    price_target: float
    news_title: str
    news_url: str
    published_date: datetime

async def get_db_connection():
    """Database dependency."""
    return conn

@app.on_event("startup")
async def startup_event():
    """Initialize database on startup."""
    conn.execute("""
    CREATE TABLE IF NOT EXISTS price_targets (
        symbol TEXT,
        analyst_name TEXT,
        analyst_company TEXT,
        published_date TIMESTAMP,
        price_target DOUBLE,
        news_title TEXT,
        news_url TEXT,
        PRIMARY KEY (symbol, analyst_name, published_date)
    )
    """)
    
    conn.execute("""
    CREATE TABLE IF NOT EXISTS analyst_scores (
        analyst_name TEXT PRIMARY KEY,
        skill_score DOUBLE,
        accuracy DOUBLE,
        avg_error DOUBLE,
        total_predictions BIGINT,
        diversity BIGINT,
        updated_at TIMESTAMP
    )
    """)
    logger.info("Database initialized on API startup")

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "version": "2.0.0", "timestamp": datetime.utcnow()}

@app.get("/top-analysts", response_model=List[AnalystScore])
async def get_top_analysts(
    limit: int = Query(10, ge=1, le=50),
    min_predictions: int = Query(5, ge=1),
    db=Depends(get_db_connection)
):
    """Get top analysts by skill score."""
    query = """
    SELECT * FROM analyst_scores 
    WHERE total_predictions >= ?
    ORDER BY skill_score DESC 
    LIMIT ?
    """
    try:
        df = pl.read_database(query, db, parameters=[min_predictions, limit])
        return df.to_dicts()
    except Exception as e:
        logger.error(f"Error fetching top analysts: {e}")
        raise HTTPException(status_code=500, detail="Database query failed")

@app.get("/analyst/{analyst_name}", response_model=List[PriceTarget])
async def get_analyst_details(
    analyst_name: str,
    days: int = Query(30, ge=1, le=365),
    db=Depends(get_db_connection)
):
    """Get detailed price targets for specific analyst."""
    one_month_ago = datetime.utcnow().replace(tzinfo=pytz.UTC) - timedelta(days=days)
    
    query = """
    SELECT * FROM price_targets 
    WHERE analyst_name = ? AND published_date >= ?
    ORDER BY published_date DESC
    """
    try:
        df = pl.read_database(
            query, db, 
            parameters=[analyst_name, one_month_ago.isoformat()]
        )
        return df.to_dicts()
    except Exception as e:
        logger.error(f"Error fetching analyst {analyst_name}: {e}")
        raise HTTPException(status_code=404, detail="Analyst not found")

@app.get("/analyst-skill/{analyst_name}")
async def get_analyst_skill(
    analyst_name: str,
    db=Depends(get_db_connection)
):
    """Get skill score for specific analyst."""
    query = "SELECT * FROM analyst_scores WHERE analyst_name = ?"
    try:
        df = pl.read_database(query, db, parameters=[analyst_name])
        if df.is_empty():
            raise HTTPException(status_code=404, detail="Analyst not found")
        return df.to_dicts()[0]
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching skill for {analyst_name}: {e}")
        raise HTTPException(status_code=500, detail="Database error")

@app.post("/analyze")
async def trigger_analysis(symbols: List[str]):
    """Trigger on-demand analysis for symbols."""
    if not API_KEY:
        raise HTTPException(status_code=401, detail="FMP_API_KEY required")
    
    # This would call the analysis function from main.py
    return {"status": "analysis_triggered", "symbols": symbols, "count": len(symbols)}

@app.get("/rss")
async def get_rss_feed():
    """Serve RSS feed (generated by scheduler)."""
    rss_path = Path("top_analysts_feed.xml")
    if rss_path.exists():
        return FileResponse(rss_path, media_type="application/xml")
    else:
        raise HTTPException(status_code=404, detail="RSS feed not generated yet")

@app.get("/leaderboard")
async def get_leaderboard_csv():
    """Download analyst leaderboard as CSV."""
    csv_path = Path("analyst_scores.csv")
    if csv_path.exists():
        return FileResponse(csv_path, media_type="text/csv", filename="leaderboard.csv")
    else:
        raise HTTPException(status_code=404, detail="Leaderboard not available")

@app.get("/stats")
async def get_stats(db=Depends(get_db_connection)):
    """System statistics."""
    total_analysts = conn.execute("SELECT COUNT(*) FROM analyst_scores").fetchone()[0]
    total_targets = conn.execute("SELECT COUNT(*) FROM price_targets").fetchone()[0]
    
    return {
        "total_analysts": int(total_analysts),
        "total_price_targets": int(total_targets),
        "last_updated": datetime.utcnow().isoformat(),
        "database_size_mb": Path(DB_PATH).stat().st_size / (1024*1024)
    }

@app.get("/search-analysts")
async def search_analysts(
    query: str,
    limit: int = Query(20, ge=1, le=100),
    db=Depends(get_db_connection)
):
    """Search analysts by name."""
    search_query = f"""
    SELECT * FROM analyst_scores 
    WHERE analyst_name ILIKE '%{query}%'
    ORDER BY skill_score DESC 
    LIMIT ?
    """
    try:
        df = pl.read_database(search_query, db, parameters=[limit])
        return df.to_dicts()
    except Exception as e:
        logger.error(f"Search error: {e}")
        raise HTTPException(status_code=500, detail="Search failed")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
